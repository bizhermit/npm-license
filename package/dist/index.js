"use strict";var __importDefault=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(exports,"__esModule",{value:!0});const fs_1=require("fs"),path_1=__importDefault(require("path")),findLicenseFileNames=e=>{const n=(0,fs_1.readdirSync)(e),s=[];for(const i of n){if(null==i.match(/^(license|licence|copying|ofl|patents)/i))continue;const n=path_1.default.join(e,i);(0,fs_1.statSync)(n).isDirectory()?(0,fs_1.readdirSync)(n).forEach((e=>s.push(path_1.default.join(i,e)))):s.push(n)}return s},readPackage=(e,n,s,i)=>{let t=null,c=n,l=[];try{if(null==e)t=JSON.parse((0,fs_1.readFileSync)(path_1.default.join(n,"package.json")).toString());else{let s=n;do{const n=path_1.default.join(c=path_1.default.join(s,"node_modules",e),"package.json");if(l.push(n),(0,fs_1.existsSync)(n)){t=JSON.parse((0,fs_1.readFileSync)(n).toString());break}const i=s.lastIndexOf("node_modules");if(i<0)break;s=s.substring(0,i-1)}while(n!==s)}}catch{}if(null==t)return s.push({type:"err",message:`\n# not found or read package.json.\n  - ${l.join("\n  - ")}\n`}),null;const r={name:t.name??"",version:t.version??"",path:c,licenses:[]},o=findLicenseFileNames(c),a=t.license||t.licence||t.licenses||t.licences;if(null!=a){const e=n=>{if(null!=n)if("string"!=typeof n)Array.isArray(n)?n.forEach((n=>e(n))):("string"==typeof n.type&&n.type.length>0&&r.licenses.push(n.type),0===o.length&&(n.path?o.push(String(n.path)):n.url&&o.push(String(n.url))));else{if(0===n.length)return;r.licenses.push(n)}};e(a)}o.length>0&&(r.licenseFile=i.absoluteLicenseFilePath?o:o.map((e=>e.replace(i.dirname,""))));const p=t.repository;null!=p&&("string"==typeof p?r.repository=p:p.url&&(r.repository=p.url??""));const d=t.author;if(null!=d)if("string"==typeof d){const e=d.match(/^([^<(]+?)?\s*(?:<([^>(]+?)>)?\s*(?:\(([^)]+?)\)|$)/);e&&(e[1]&&(r.publisher=e[1]),e[2]&&(r.email=e[2]),e[3]&&(r.url=e[3]))}else d.name&&(r.publisher=d.name),d.email&&(r.email=d.email),d.url&&(r.url=d.url);const u=t.dependencies??{},f=t.devDependencies??{};return{pkg:r,deps:u,devDeps:f}},collect=(e,n)=>{const s=readPackage(null,e.dirname,n,e);if(null==s)return void n.push({type:"err",message:"not found root package.json"});const i=n=>!(!0===e.includePrivate||!n.private),t=(s,t)=>{Object.keys(s).forEach((s=>{const c=readPackage(s,e.dirname,n,e);if(null==c||i(c.pkg))return;const l={},r=(s,i)=>{Object.keys(s).forEach((s=>{if(null!=l[s])return;const t=readPackage(s,i.path,n,e);null!=t&&(l[s]=t.pkg,r(t.deps,t.pkg))}))};r(c.deps,c.pkg),Object.keys(l).forEach((e=>{null==c.pkg.dependencies&&(c.pkg.dependencies=[]),c.pkg.dependencies.push(l[e])})),t(c.pkg)}))};return t(s.deps,(e=>{i(e)||(null==s.pkg.dependencies&&(s.pkg.dependencies=[]),s.pkg.dependencies.push(e))})),e.includeDevDependencies&&t(s.devDeps,(e=>{i(e)||(null==s.pkg.devDependencies&&(s.pkg.devDependencies=[]),s.pkg.devDependencies.push(e))})),s.pkg},validate=(e,n)=>{const s=n??[],i=(n,t,c)=>{const l=`\n  ${n.name}@${n.version}: ${n.licenses.join(",")}\n  ${c?"-":"+"} ${t.name}@${t.version}: ${t.licenses.join(",")}`,r=n=>!((e.excludes?.indexOf(t.name)??-1)>=0)&&(s.push({type:"err",message:n}),!0);if(0===t.licenses.length)r(`\n# use unkown or not extract license${l}`);else for(const e of t.licenses)null==e||0===e.length?r(`\n# use unkown or not extract license${l}`):e.match(/^cc0/i)||(e.match(/^cc.*4/i)?r(`\n# use need to acknowledgments license${l}`):e.match(/mit/i)||e.match(/isc/i)||e.match(/(0bsd|bsd*.0)/i)||e.match(/bsd*.3/i)||e.match(/bsd*.2/i)||(e.match(/(bsd|bsd*.4)/i)?r(`\n# use need to acknowledgments license${l}`):e.match(/apache.*2/i)||(e.match(/apache.*1/i)||e.match(/mpl/i)||e.match(/mpl/i)?r(`\n# use complex license${l}`):r(`\n# use not supported license${l}`))));t.dependencies?.forEach((e=>i(t,e,!1))),t.devDependencies?.forEach((e=>i(t,e,!0)))};return e.pkg.dependencies?.forEach((n=>i(e.pkg,n,!1))),e.pkg.devDependencies?.forEach((n=>i(e.pkg,n,!0))),s},format=e=>"json"===e.format?formatToJson(e):"csv"===e.format?formatToCsv(e):formatToList(e),endLine="\n",isRequiredToAddLicense=e=>{if(null==e.licenses)return!1;for(const n of e.licenses){if(n.match(/bsd.*4/i))return!0;if(n.match(/^cc.*4/i))return!0}return!1},formatToList=e=>{const n=(s,i,t)=>{let c="";s.dependencies&&s.dependencies.length>0&&s.dependencies.forEach((e=>{c+=n(e,i+1)})),s.devDependencies&&s.devDependencies.length>0&&s.devDependencies.forEach((e=>{c+=n(e,i+1,!0)}));let l="";if(""===c&&!isRequiredToAddLicense(s)&&!0!==e.all)return l;const r="|   ".repeat(Math.max(0,i-(!0===e?.includeRoot?0:1))),o=e=>l+=r+e+"\n";return(i>0||!0===e.includeRoot)&&(o(`${(t?"-":"+")+" "}${s.name}`),o(`|   version: ${s.version}`),o(`|   license: ${s.licenses.join(",")??""}`),s.licenseFile&&s.licenseFile.length>0&&o(`|   licenseFile: ${s.licenseFile.join(",")}`),s.publisher&&o(`|   publisher: ${s.publisher}`),s.email&&o(`|   email: ${s.email}`),s.url&&o(`|   url: ${s.url}`),s.repository&&o(`|   repository: ${s.repository}`)),l+=c,l};return n(e.pkg,0)},formatToJson=e=>!0===e.includeRoot?JSON.stringify(e.pkg,null,2):JSON.stringify({...e.pkg.dependencies??{},...e.pkg.devDependencies??{}},null,2),formatToCsv=e=>formatToList(e),license={collect:collect,validate:validate,format:format};exports.default=license;